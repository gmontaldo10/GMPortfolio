<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Singularity III</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <style>
        /* GLOBAL RESET & SHARED */
        body, html {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            /* Default state: Locked for Phase 1 */
            width: 100%;
            height: 100%;
            overflow: hidden; 
        }

        /* PHASE 1 STYLES */
        #phase1-root {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #canvas-container-p1 {
            width: 100vw; height: 100vh;
            position: absolute; top: 0; left: 0;
            z-index: 1; cursor: crosshair; 
        }

        #ui-layer-p1 {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.8);
            transition: opacity 2s;
        }

        #start-btn-p1 {
            background: transparent;
            border: 1px solid rgba(255, 165, 0, 0.5);
            color: rgba(255, 165, 0, 0.8);
            padding: 20px 60px;
            font-family: inherit; font-size: 1rem; letter-spacing: 12px;
            cursor: pointer; pointer-events: auto;
            transition: all 0.5s; text-transform: uppercase;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.2);
        }
        #start-btn-p1:hover {
            border-color: #fff; color: #fff;
            box-shadow: 0 0 60px rgba(255, 100, 0, 0.6);
            background: rgba(255, 165, 0, 0.1);
        }

        /* PHASE 2 STYLES */
        #phase2-root {
            display: none; /* Hidden initially */
            opacity: 0;
            transition: opacity 3s ease-in;
            font-family: 'Space Mono', monospace;
            width: 100%; 
            /* min-height handled by content */
            position: relative;
            z-index: 500;
        }

        /* CRITICAL FIX FOR SCROLLING */
        html.phase2-active, body.phase2-active {
            height: auto !important;
            min-height: 100% !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            cursor: grab; /* Indicate dragging is possible */
        }
        
        html.phase2-active:active {
            cursor: grabbing;
        }

        ::-webkit-scrollbar { width: 0px; background: transparent; }

        #canvas-container-p2 {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; pointer-events: none;
        }

        .content-wrapper {
            position: relative; z-index: 10;
            width: 100%; max-width: 800px; margin: 0 auto;
            padding-bottom: 50vh;
            pointer-events: none; /* Let clicks pass through to document for dragging */
        }

        .narrative-section {
            min-height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; opacity: 0; transition: opacity 1s ease; padding: 2rem;
        }

        .distortable {
            transform-origin: center bottom;
            will-change: transform, color, filter;
            transition: transform 0.1s linear;
        }

        .metric-display {
            position: fixed; bottom: 20px; right: 20px;
            font-size: 0.8rem; color: #555; text-align: right; z-index: 20;
            pointer-events: none;
        }

        h1, h2 { font-family: 'Cinzel', serif; text-transform: uppercase; letter-spacing: 0.2em; }
        
        .red-glow { text-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }

        /* PHASE 3 STYLES */
        #phase3-root {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000;
            justify-content: center; align-items: center;
            gap: 100px; /* Space between lights */
            opacity: 0;
            transition: opacity 2s ease-in;
        }

        .purple-light {
            width: 20px; height: 20px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 60px 20px rgba(147, 51, 234, 0.8); /* Purple glow */
            animation: oscilate 4s ease-in-out infinite;
        }

        /* Offset the second light slightly */
        .purple-light:nth-child(2) {
            animation-delay: 2s;
        }

        @keyframes oscilate {
            0%, 100% { opacity: 0.3; transform: scale(0.8); box-shadow: 0 0 30px 10px rgba(147, 51, 234, 0.4); }
            50% { opacity: 1; transform: scale(1.2); box-shadow: 0 0 100px 40px rgba(147, 51, 234, 1.0); }
        }

        #final-message {
            position: fixed;
            bottom: 40px;
            right: 40px;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.9);
            opacity: 0;
            z-index: 2001;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 3s ease-in;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: shine 4s ease-in-out infinite alternate;
        }

        @keyframes shine {
            0% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.3); opacity: 0.7; }
            100% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 0 0 40px rgba(200, 200, 255, 0.5); opacity: 1; }
        }
    </style>
</head>
<body>

<!-- PHASE 1: GENESIS -->
<div id="phase1-root">
    <div id="ui-layer-p1">
        <button id="start-btn-p1">SINGULARITY</button>
    </div>
    <div id="canvas-container-p1"></div>
</div>

<!-- PHASE 2: OBSERVING -->
<div id="phase2-root">
    <canvas id="canvas-container-p2"></canvas>

    <div class="metric-display" id="hud">
        <div>TIME FLOW: <span id="time-flow-val">100%</span></div>
        <div>GRAVITY: <span id="gravity-val">1.0G</span></div>
        <div>SHIFT: <span id="shift-val">0nm</span></div>
    </div>

    <div class="content-wrapper" id="content">
        <!-- Index 0 is shown immediately -->
        <section class="narrative-section" data-index="0">
            <h1 class="distortable">The Observer</h1>
            <p class="distortable text-gray-300">
                Your brain perceives the singularity from a stabilized reference frame.
                <br><br>
                Time still flows linearly. The light is clear.
            </p>
            <div class="mt-12 text-sm text-gray-500 animate-bounce" id="scroll-hint">SCROLL OR DRAG TO DESCEND</div>
        </section>

        <section class="narrative-section" data-index="1">
            <h2 class="distortable">The Ergosphere</h2>
            <p class="distortable">
                Gravity begins to take hold. The clock feels heavier. 
                Space is being dragged around the rotating mass.
            </p>
        </section>

        <section class="narrative-section" data-index="2">
            <h2 class="distortable text-red-300">Photon Sphere</h2>
            <p class="distortable text-red-200">
                Light orbits the hole. You can see the back of our own head.
                Time is stretching. A second takes an eternity.
            </p>
        </section>

        <section class="narrative-section" data-index="3">
            <h1 class="distortable text-red-500 red-glow">Event Horizon</h1>
            <p class="distortable text-red-600 font-bold" style="font-size: 1.5rem;">
                NO RETURN.
                <br>
                LIGHT FREEZES. TIME STOPS.
            </p>
        </section>
        <div style="height: 20vh;"></div>
    </div>
</div>

<!-- PHASE 3: THE VOID -->
<div id="phase3-root">
    <div class="purple-light"></div>
    <div class="purple-light"></div>
    <div id="final-message">The persistent illusion of time passing.</div>
</div>

<!-- Three.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

<script>
// ==========================================
// SHARED AUDIO SYSTEM
// ==========================================
class MasterAudio {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);
        
        // Effects
        this.delay = this.ctx.createDelay();
        this.delay.delayTime.value = 0.4;
        this.feedback = this.ctx.createGain();
        this.feedback.gain.value = 0.4;
        this.delay.connect(this.feedback);
        this.feedback.connect(this.delay);
        this.delay.connect(this.masterGain);

        // Create a Noise Buffer for whispers/wind
        const bufferSize = this.ctx.sampleRate * 4; // 4 seconds for longer textures
        this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            // Pink noise approximation
            const white = Math.random() * 2 - 1;
            data[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = data[i];
            data[i] *= 3.5; // compensate for gain loss
        }
    }

    resume() {
        if(this.ctx.state === 'suspended') this.ctx.resume();
    }
}

let lastOut = 0;
let audioSys = null;
let phase3Heartbeat = null; // To track the rumble oscillator

// ==========================================
// PHASE 1: LOGIC (SINGULARITY GENESIS)
// ==========================================
const galaxyVertexShader = `
uniform float uTime;
uniform float uCollapse; 
attribute float aSize;
attribute float aSpeed;
attribute float aOffset;
attribute float aDist; 
varying vec3 vColor;
void main() {
    float angle = uTime * aSpeed * (12.0 / (aDist + 1.0)) + aOffset;
    float collapseFactor = pow(uCollapse, 3.0); 
    float currentR = mix(aDist, 0.0, collapseFactor); 
    float screamAngle = angle + (uCollapse * 25.0 * aSpeed); 
    float x = currentR * cos(screamAngle);
    float z = currentR * sin(screamAngle);
    float y = (sin(uTime * 30.0 + aDist) * uCollapse * 6.0); 
    vec3 pos = vec3(x, y, z);
    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = aSize * (500.0 / -mvPosition.z);
    float intensity = 1.0 - smoothstep(0.0, 60.0, aDist);
    vec3 cInner = vec3(0.7, 0.9, 1.0); 
    vec3 cOuter = vec3(0.2, 0.0, 0.4); 
    vec3 baseColor = mix(cOuter, cInner, intensity);
    vColor = mix(baseColor, vec3(1.0), uCollapse * 0.9); 
}`;

const galaxyFragmentShader = `
varying vec3 vColor;
void main() {
    vec2 xy = gl_PointCoord.xy - vec2(0.5);
    float ll = length(xy);
    if(ll > 0.5) discard;
    float alpha = 1.0 - smoothstep(0.3, 0.5, ll);
    gl_FragColor = vec4(vColor, alpha * 0.85); 
}`;

class Phase1Simulation {
    constructor() {
        this.container = document.getElementById('canvas-container-p1');
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        
        this.initialRadius = 60.0; 
        this.currentRadius = this.initialRadius;
        this.targetRadius = this.initialRadius;
        
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.position.set(0, 0, this.currentRadius);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.clicks = 0;
        this.maxClicks = 7; 
        this.phase = 'orbit'; 
        this.time = 0;
        
        this.isDragging = false;
        this.startDragTime = 0;
        this.prevMouse = { x: 0, y: 0 };
        
        this.rotationX = 0; 
        this.rotationY = 0.18; 

        this.initWorld();
        this.bindEvents();
        this.startP1Audio();
    }

    startP1Audio() {
        // Drone
        const osc = audioSys.ctx.createOscillator();
        const gain = audioSys.ctx.createGain();
        osc.frequency.value = 40; osc.type = 'triangle';
        const filter = audioSys.ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 100;
        gain.gain.value = 0.3;
        osc.connect(filter); filter.connect(gain);
        gain.connect(audioSys.masterGain);
        gain.connect(audioSys.delay);
        osc.start();
        this.droneOsc = osc;
        this.droneGain = gain;

        // Heartbeat
        this.tickInterval = setInterval(() => {
            const t = audioSys.ctx.currentTime;
            const k = audioSys.ctx.createOscillator();
            const g = audioSys.ctx.createGain();
            k.frequency.setValueAtTime(150, t);
            k.frequency.exponentialRampToValueAtTime(0.01, t + 0.3);
            g.gain.setValueAtTime(0.3, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
            k.connect(g); g.connect(audioSys.masterGain);
            k.start(); k.stop(t + 0.35);
        }, 1500);
    }

    // UPDATED: Airy/Whisper Texture (Reverse Breath)
    playClickSound(clickIndex) {
        const t = audioSys.ctx.currentTime;
        
        // Intensity scales with clicks (0 to 1)
        const intensity = Math.min(1, clickIndex / this.maxClicks);
        
        // 1. Source: Noise Buffer
        const source = audioSys.ctx.createBufferSource();
        source.buffer = audioSys.noiseBuffer;
        source.playbackRate.value = 0.5 + (Math.random() * 0.2); // Slow playback for wind texture
        source.loop = true; // We will gate it with gain

        // 2. Filter: Bandpass to create "Airy" whistle
        const filter = audioSys.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.Q.value = 1.0; // Wide-ish bandwidth
        // Frequency rises slightly with intensity to sound "sharper"
        filter.frequency.setValueAtTime(200 + (intensity * 600), t);

        // 3. Gain Envelope: "Reverse Breath" Shape
        const gain = audioSys.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        
        // Slow attack (The inhale/reverse feel)
        const attackTime = 0.8 - (intensity * 0.3); // Gets slightly faster/sharper as we go
        gain.gain.linearRampToValueAtTime(0.4 + (intensity * 0.4), t + attackTime); 
        
        // Fast release (The cut)
        gain.gain.exponentialRampToValueAtTime(0.001, t + attackTime + 0.5);

        // 4. Pan (Optional spatial)
        const panner = audioSys.ctx.createStereoPanner();
        panner.pan.value = (Math.random() * 2) - 1;

        // Connect Graph
        source.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(audioSys.masterGain);
        // Send to delay for that "Exhale into universe" feel
        gain.connect(audioSys.delay);

        source.start(t);
        source.stop(t + attackTime + 1.0);
    }

    initWorld() {
        const geoSphere = new THREE.SphereGeometry(2.0, 64, 64);
        const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
        this.singularity = new THREE.Mesh(geoSphere, matBlack);
        this.scene.add(this.singularity);

        const particleCount = 75000;
        const galaxyGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const speeds = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        const dists = new Float32Array(particleCount);
        
        for(let i=0; i<particleCount; i++) {
            const armIndex = i % 5; 
            const r = 3.5 + (Math.pow(Math.random(), 2) * 70.0); 
            const spinAngle = r * 0.6;
            const armAngle = (Math.PI * 2 / 5) * armIndex;
            const theta = spinAngle + armAngle + (Math.random() - 0.5) * 0.6;
            positions[i*3] = r * Math.cos(theta);
            positions[i*3+1] = (Math.random() - 0.5) * (Math.exp(-r * 0.08) * 3.0); 
            positions[i*3+2] = r * Math.sin(theta);
            dists[i] = r;
            sizes[i] = Math.random();
            speeds[i] = Math.random() * 0.5 + 0.5;
            offsets[i] = Math.random() * Math.PI * 2;
        }
        galaxyGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        galaxyGeo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        galaxyGeo.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));
        galaxyGeo.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));
        galaxyGeo.setAttribute('aDist', new THREE.BufferAttribute(dists, 1));
        
        this.galaxyUniforms = { uTime: { value: 0 }, uCollapse: { value: 0 } };
        const galaxyMat = new THREE.ShaderMaterial({
            uniforms: this.galaxyUniforms, vertexShader: galaxyVertexShader, fragmentShader: galaxyFragmentShader,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        this.galaxy = new THREE.Points(galaxyGeo, galaxyMat);
        this.scene.add(this.galaxy);

        const geoCage = new THREE.IcosahedronGeometry(2.4, 1);
        const matCage = new THREE.MeshBasicMaterial({ 
            color: 0xff6600, wireframe: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        this.cage = new THREE.Mesh(geoCage, matCage);
        this.scene.add(this.cage);

        const ringGeo = new THREE.TorusGeometry(2.2, 0.03, 32, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
        this.ring1 = new THREE.Mesh(ringGeo, ringMat);
        this.ring2 = new THREE.Mesh(ringGeo, ringMat);
        this.ring1.rotation.x = Math.PI/2; this.ring2.rotation.x = Math.PI/2; this.ring2.rotation.y = 1.57; 
        this.scene.add(this.ring1); this.scene.add(this.ring2);
    }

    bindEvents() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const handleStart = (x, y) => {
            if (this.phase === 'ended') return;
            this.isDragging = true; this.prevMouse = { x, y }; this.startDragTime = Date.now(); this.dragStartPos = {x, y};
        };
        
        const handleMove = (x, y) => {
            if (this.phase === 'ended') return;
            if (!this.isDragging || this.phase === 'collapsing') return;
            const dx = x - this.prevMouse.x; const dy = y - this.prevMouse.y;
            this.rotationX -= dx * 0.002; this.rotationY -= dy * 0.002;
            this.rotationY = Math.max(-1.5, Math.min(1.5, this.rotationY));
            this.prevMouse = { x, y };
        };
        
        const handleEnd = (x, y) => {
            if (this.phase === 'ended') return;
            this.isDragging = false;
            const time = Date.now() - this.startDragTime;
            const dist = Math.sqrt(Math.pow(x - this.dragStartPos.x, 2) + Math.pow(y - this.dragStartPos.y, 2));
            if (time < 400 && dist < 20) this.handleTap(x, y);
        };

        window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));
        
        window.addEventListener('touchstart', e => {
            if (this.phase === 'ended') return;
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive:false});
        
        window.addEventListener('touchmove', e => { 
            if (this.phase !== 'ended') {
                e.preventDefault(); 
                handleMove(e.touches[0].clientX, e.touches[0].clientY); 
            }
        }, {passive:false});
        
        window.addEventListener('touchend', e => { 
            if (this.phase === 'ended') return;
            const t = e.changedTouches[0]; 
            handleEnd(t.clientX, t.clientY); 
        });
    }

    handleTap(x, y) {
        if (this.phase === 'collapsing' || this.phase === 'locked') return;
        this.mouse.x = (x / window.innerWidth) * 2 - 1;
        this.mouse.y = -(y / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObject(this.singularity);
        const distFromCenter = this.mouse.length();
        
        if (intersects.length > 0 || distFromCenter < 0.4) {
            this.advancePhase();
        }
    }

    advancePhase() {
        if (this.clicks >= this.maxClicks) return;
        this.clicks++;
        this.playClickSound(this.clicks);

        const progress = this.clicks / this.maxClicks;
        
        if (this.clicks < this.maxClicks) {
            this.targetRadius = this.initialRadius * Math.pow(0.18, progress); 
        } else {
            this.targetRadius = 6.0; 
            this.phase = 'locked';
            setTimeout(() => this.startCollapse(), 1000);
        }
    }

    startCollapse() {
        this.phase = 'collapsing';
        clearInterval(this.tickInterval);
        
        const t = audioSys.ctx.currentTime;
        const osc = audioSys.ctx.createOscillator();
        const gain = audioSys.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(40, t);
        osc.frequency.exponentialRampToValueAtTime(12000, t + 4.0);
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.linearRampToValueAtTime(0.8, t + 3.5);
        gain.gain.linearRampToValueAtTime(0, t + 4.0);
        osc.connect(gain); gain.connect(audioSys.masterGain);
        osc.start(); osc.stop(t + 4.1);

        setTimeout(() => {
            this.destroyAndSwitch();
        }, 4000);
    }

    update() {
        if(this.stopped) return;
        requestAnimationFrame(this.update.bind(this));
        
        const dt = 0.016; this.time += dt;
        this.galaxyUniforms.uTime.value = this.time;
        this.currentRadius += (this.targetRadius - this.currentRadius) * 0.04;

        if (this.phase === 'collapsing') {
            const rate = 0.25;
            this.galaxyUniforms.uCollapse.value += dt * rate;
            const cVal = this.galaxyUniforms.uCollapse.value;
            const scale = Math.max(0, 1.0 - (cVal * 1.1));
            this.cage.scale.setScalar(2.4 * scale);
            this.ring1.scale.setScalar(scale); this.ring2.scale.setScalar(scale);
            
            const shake = cVal * 0.8;
            const sx = (Math.random() - 0.5) * shake;
            const sy = (Math.random() - 0.5) * shake;
            const sz = (Math.random() - 0.5) * shake;
            const cx = this.currentRadius * Math.sin(this.rotationX) * Math.cos(this.rotationY);
            const cy = this.currentRadius * Math.sin(this.rotationY);
            const cz = this.currentRadius * Math.cos(this.rotationX) * Math.cos(this.rotationY);
            this.camera.position.set(cx+sx, cy+sy, cz+sz);
        } else {
            const cx = this.currentRadius * Math.sin(this.rotationX) * Math.cos(this.rotationY);
            const cy = this.currentRadius * Math.sin(this.rotationY);
            const cz = this.currentRadius * Math.cos(this.rotationX) * Math.cos(this.rotationY);
            this.camera.position.set(cx, cy, cz);
            this.cage.rotation.y -= 0.08 * dt; this.cage.rotation.z += 0.03 * dt;
            this.ring1.rotation.z += 0.1 * dt; this.ring2.rotation.z -= 0.08 * dt;
        }
        this.camera.lookAt(0, 0, 0);
        this.renderer.render(this.scene, this.camera);
    }

    destroyAndSwitch() {
        this.stopped = true;
        this.phase = 'ended'; // Flag to stop capturing events
        this.droneGain.gain.linearRampToValueAtTime(0, audioSys.ctx.currentTime + 1);
        document.getElementById('phase1-root').style.display = 'none';
        initPhase2();
    }
}

// ==========================================
// PHASE 2: LOGIC (OBSERVING SINGULARITY)
// ==========================================
function initPhase2() {
    const root = document.getElementById('phase2-root');
    
    document.documentElement.classList.add('phase2-active');
    document.body.classList.add('phase2-active');

    root.style.display = 'block';
    setTimeout(() => {
        root.style.opacity = 1;
    }, 100);

    const canvas = document.getElementById('canvas-container-p2');
    const ctx = canvas.getContext('2d');
    const sections = document.querySelectorAll('.narrative-section');
    const hud = document.getElementById('hud');
    const timeVal = document.getElementById('time-flow-val');
    const gravVal = document.getElementById('gravity-val');
    const shiftVal = document.getElementById('shift-val');

    const firstSec = document.querySelector('.narrative-section[data-index="0"]');
    if(firstSec) firstSec.style.opacity = 1;

    let scrollPct = 0;
    let stars = [];
    let tripMode = false;
    let globalTime = 0;

    const droneOsc = audioSys.ctx.createOscillator();
    const droneGain = audioSys.ctx.createGain();
    droneOsc.type = 'sawtooth'; droneOsc.frequency.value = 50;
    const filter = audioSys.ctx.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.value = 200;
    droneOsc.connect(filter); filter.connect(droneGain);
    droneGain.connect(audioSys.masterGain);
    droneGain.gain.value = 0.1;
    droneOsc.start();

    let nextTickTime = audioSys.ctx.currentTime;
    let tickHandle = null;
    
    function scheduleTick() {
        const ct = audioSys.ctx.currentTime;
        if (tripMode) return; 
        
        while(nextTickTime < ct + 0.1) {
            const osc = audioSys.ctx.createOscillator();
            const g = audioSys.ctx.createGain();
            let freq = 800 * (1 - scrollPct * 0.5);
            osc.frequency.setValueAtTime(freq, nextTickTime);
            osc.type = 'square';
            g.gain.setValueAtTime(0.05, nextTickTime);
            g.gain.exponentialRampToValueAtTime(0.001, nextTickTime+0.1);
            osc.connect(g); g.connect(audioSys.masterGain);
            osc.start(nextTickTime); osc.stop(nextTickTime+0.1);
            
            let interval = 1.0 * (1 + (scrollPct*6));
            nextTickTime += interval;
        }
        tickHandle = requestAnimationFrame(scheduleTick);
    }
    scheduleTick();

    class Star {
        constructor(w, h) { this.init(w, h); }
        init(w, h) {
            this.x = (Math.random()-0.5)*w*2; 
            this.y = (Math.random()-0.5)*h*2;
            this.z = Math.random()*w; 
            this.baseSize = Math.random()*2;
            this.hue = Math.random()*360; 
            this.waveOffset = Math.random() * Math.PI * 2;
        }
        update(w, h, speed) {
            let s = tripMode ? speed*20 : speed;
            this.z -= s;
            if(scrollPct > 0.2 && !tripMode) {
                const angle = 0.02 * scrollPct;
                const cos = Math.cos(angle), sin = Math.sin(angle);
                const nx = this.x*cos - this.y*sin, ny = this.x*sin + this.y*cos;
                this.x=nx; this.y=ny;
            }
            if(this.z <= 1) { this.init(w, h); this.z = w; }
        }
        draw(w, h) {
            const cx = w/2, cy = h/2;
            const k = 128.0/this.z;
            const px = this.x*k + cx, py = this.y*k + cy;
            if(px<0 || px>w || py<0 || py>h) return;
            
            let size = (1 - this.z/w) * this.baseSize * 4;
            if(tripMode) size *= 3;
            
            let stroke;
            let stretch = 1 + (scrollPct*scrollPct*50);
            
            if(tripMode) {
                let l = 50 + Math.random()*20;
                stroke = `hsl(${this.hue}, 100%, ${l}%)`;
                stretch = 50; this.hue+=5;
            } else {
                let r=255-(scrollPct*100), g=255-(scrollPct*255), b=255-(scrollPct*255);
                stroke = `rgba(${r},${g},${b},${1-this.z/w})`;
            }
            
            ctx.beginPath(); 
            ctx.strokeStyle = stroke; 
            ctx.lineWidth = size; 
            ctx.lineCap='round';

            if(tripMode) {
                const tailLength = size * stretch;
                const segments = 20;
                const dx = px - cx;
                const dy = py - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const ux = dx/dist;
                const uy = dy/dist;

                ctx.moveTo(px, py);
                
                for(let i=0; i<segments; i++) {
                    const progress = i / segments;
                    const distBack = progress * tailLength;
                    
                    const waveFreq = 10.0; 
                    const waveAmp = 10.0 * (1.0 - progress); 
                    const wavePhase = (globalTime * 15) + this.waveOffset + (progress * 5);
                    
                    const offsetVal = Math.sin(wavePhase) * waveAmp;
                    const offsetX = -uy * offsetVal;
                    const offsetY = ux * offsetVal;

                    const bx = px - (ux * distBack);
                    const by = py - (uy * distBack);
                    
                    ctx.lineTo(bx + offsetX, by + offsetY);
                }
                ctx.stroke();

            } else {
                const dx = px-cx, dy = py-cy;
                const dist = Math.sqrt(dx*dx+dy*dy);
                const ux = dx/dist, uy = dy/dist;
                ctx.moveTo(px,py);
                ctx.lineTo(px-(ux*size*stretch), py-(uy*size*stretch));
                ctx.stroke();
            }
        }
    }

    function resize() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        stars = [];
        for(let i=0; i<800; i++) stars.push(new Star(canvas.width, canvas.height));
    }
    window.addEventListener('resize', resize);
    resize();

    function animate() {
        globalTime += 0.016;
        if(root.style.display === 'none') return;

        ctx.fillStyle = tripMode ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.3)';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        
        let speed = 2 * (1 - (scrollPct*0.9));
        if(tripMode) speed=5;
        
        stars.forEach(s => { 
            s.update(canvas.width, canvas.height, speed); 
            s.draw(canvas.width, canvas.height); 
        });
        
        if(!tripMode) droneOsc.frequency.setTargetAtTime(50-(scrollPct*30), audioSys.ctx.currentTime, 0.1);
        
        requestAnimationFrame(animate);
    }
    animate();

    let isDragging = false;
    let startY = 0;
    let startScroll = 0;

    window.addEventListener('mousedown', (e) => {
        if(tripMode) return;
        isDragging = true;
        startY = e.pageY;
        startScroll = window.scrollY;
        document.body.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', (e) => {
        if(!isDragging || tripMode) return;
        e.preventDefault(); 
        const delta = startY - e.pageY;
        window.scrollTo(0, startScroll + delta);
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.style.cursor = 'grab';
    });

    function handleScroll() {
        if(tripMode) return;
        const st = window.scrollY;
        const dh = document.body.scrollHeight - window.innerHeight;
        
        if (dh <= 0) return; 

        let p = st/dh; if(p<0)p=0; if(p>1)p=1;
        scrollPct = p;

        if(scrollPct > 0.99) triggerTrip();

        timeVal.innerText = `${Math.max(0, 100-(p*99.9)).toFixed(2)}%`;
        gravVal.innerText = `${(1+(p*50)).toFixed(1)}G`;
        shiftVal.innerText = `${(p*700).toFixed(0)}nm`;
        timeVal.style.color = `rgb(255, ${255-p*255}, ${255-p*255})`;

        document.querySelectorAll('.distortable').forEach(el => {
            const sy = 1+(p*p*5);
            el.style.transform = `scaleY(${sy})`;
            el.style.filter = `blur(${p*4}px)`;
            el.style.color = `rgb(${255},${255-p*255},${255-p*255})`;
            el.style.letterSpacing = `${p*10}px`;
        });
        
        sections.forEach(sec => {
            const r = sec.getBoundingClientRect();
            if (sec.getAttribute('data-index') === "0") {
                sec.style.opacity = (r.top < window.innerHeight * 0.8) ? 1 - (p*1.5) : 0;
            } else {
                sec.style.opacity = (r.top < window.innerHeight*0.8 && r.bottom > 0) ? 1 : 0.2;
            }
        });
    }
    window.addEventListener('scroll', () => requestAnimationFrame(handleScroll));

    function triggerTrip() {
        tripMode = true;
        document.body.style.overflow = 'hidden'; 
        document.getElementById('content').style.opacity = 0;
        hud.style.opacity = 0;

        droneGain.gain.exponentialRampToValueAtTime(0.001, audioSys.ctx.currentTime + 0.1);
        playGraveSound();

        setTimeout(() => {
            canvas.style.opacity = 0; 
            root.style.opacity = 0; 
            
            setTimeout(() => {
                root.style.display = 'none';
                initPhase3();
            }, 2000); 
        }, 3000);
    }

    function playGraveSound() {
        const t = audioSys.ctx.currentTime;
        const freqs = [55, 110, 54, 108]; 
        freqs.forEach(f => {
            const o = audioSys.ctx.createOscillator();
            const g = audioSys.ctx.createGain();
            o.type = 'sawtooth';
            o.frequency.value = f;
            
            const fil = audioSys.ctx.createBiquadFilter();
            fil.type = 'lowpass';
            fil.frequency.setValueAtTime(100, t);
            fil.frequency.exponentialRampToValueAtTime(50, t + 3); 

            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.15, t + 0.5);
            g.gain.exponentialRampToValueAtTime(0.001, t + 6); 
            
            o.connect(fil); fil.connect(g); 
            g.connect(audioSys.masterGain);
            o.start(t); o.stop(t + 6);
        });
    }
}

// ==========================================
// PHASE 3: LOGIC (THE VOID)
// ==========================================
function initPhase3() {
    const root = document.getElementById('phase3-root');
    root.style.display = 'flex';
    
    // Start the heartbeat audio
    playVoidHeartbeat();

    // Fade visual in
    setTimeout(() => {
        root.style.opacity = 1;
    }, 100);

    // Show text after 8 seconds
    setTimeout(() => {
        document.getElementById('final-message').style.opacity = 1;
    }, 8000);
}

// NEW: Phase 3 Audio Generator (Sub-harmonic rumble + Heartbeat pulse)
function playVoidHeartbeat() {
    const t = audioSys.ctx.currentTime;
    
    // 1. The Rumble (Sub-bass sawtooths)
    // We use two oscillators slightly detuned to create movement/phasing
    const osc1 = audioSys.ctx.createOscillator();
    const osc2 = audioSys.ctx.createOscillator();
    osc1.type = 'sawtooth'; osc2.type = 'sawtooth';
    osc1.frequency.value = 40; // Deep sub
    osc2.frequency.value = 41; // Beat frequency = 1Hz
    
    // 2. Lowpass Filter (Muffle the saw to make it "felt not heard")
    const filter = audioSys.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 80; 

    // 3. Heartbeat Pulse (LFO Amplitude Modulation)
    const lfo = audioSys.ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.6; // Slow pulse (BPM ~ 36)

    // LFO needs to control a gain node. 
    // We want the gain to go from roughly 0.2 to 0.8
    const lfoGain = audioSys.ctx.createGain();
    lfoGain.gain.value = 0.3; // Amplitude of modulation
    lfo.connect(lfoGain);

    const mainGain = audioSys.ctx.createGain();
    mainGain.gain.value = 0.5; // Base volume
    lfoGain.connect(mainGain.gain); // Modulation connection

    // 4. Master Connection
    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(mainGain);
    mainGain.connect(audioSys.masterGain);

    // Start everything
    osc1.start(t);
    osc2.start(t);
    lfo.start(t);
}


// ==========================================
// ENTRY POINT
// ==========================================
document.getElementById('start-btn-p1').addEventListener('click', () => {
    // Hide UI
    document.getElementById('ui-layer-p1').style.opacity = 0;
    setTimeout(() => document.getElementById('ui-layer-p1').style.display = 'none', 1500);
    
    // Init Audio
    audioSys = new MasterAudio();
    audioSys.resume();
    
    // Start Phase 1
    window.phase1 = new Phase1Simulation();
    window.phase1.update();
});

</script>
</body>
</html>